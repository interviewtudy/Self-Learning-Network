# DNS와 자원

## 도메인 네임과 네임 서버

- 사용자는 상대 호스트를 특정하기 위해 IP 주소보다는 도메인 네임을 많이 사용함
- 도메인 네임과 IP 주소는 네임 서버에서 관리
- DNS 서버: 도메인 네임을 관리하는 네임 서버
- 도메인 네임을 네임 서버에 질의하면 도메인 네임에 대한 IP 주소를 알려 주고 반대로 IP 주소를 통해 도메인 네임을 알아내는 것도 가능함
- hosts 파일은 호스트마다 개별적으로 보유하는 파일로 도메인 주소와 IP 주소의 대응 관계를 담고 있음
- 도메인 네임은 점(.)을 기준으로 계층적으로 분류됨.
- www.example.com. 에서 마지막 .이 루트 도메인, com 이 최상위 도메인(TLD), example 이 2단계 도메인, www 가 3단계 도메인
- 루트 도메인은 일반적으로 생략해서 표기하기 때문에 대개 최상위 도메인이 도메인 네임의 마지막 부분으로 간주
- 전체 주소 도메인 네임(FQDN: Fully-Qualified Domain Name): 루트 도메인을 포함한 도메인 네임 (ex.www.example.com.)
- 호스트 네임: FQDN 의 첫 번째 부분 (ex.www). 때로는 FQDN 자체를 가리키거나 네트워크상의 장치 자체의 이름을 가리키는데 사용되기도 함
- 도메인 네임 시스템(DNS: Domain Name System): 네임 서버는 여러 개 존재하며 전 세계 여러 군데에 위치하는데, 이런 계층적이고 분산된 도메인 네임에 대한 관리 체계이자 이를 관리하는 프로토콜
- 서브 도메인: 다른 도메인이 포함된 도메인 (ex.google.com의 서브도메인은 www.google.com, mail.google.com)

<br/><br/>

## 계층적 네임 서버

- 도메인 네임 풀이(resolving): IP 주소를 모르는 상태에서 도메인 네임에 대응되는 IP 주소를 알아내는 과정
- 네임 서버의 유형
  - 로컬 네임 서버: 클라이언트와 맞닿아 있는 네임 서버로, 클라이언트가 도메인 네임을 통해 IP 주소를 알아내려고 할 때 가장 먼저 찾게되는 네임서버. 로컬 네임 서버의 주소는 일반적으로 ISP 에서 할당해주는 경우가 많고, 공개 DNS 서버를 이용할 수도 있음
  - 루트 네임 서버: 로컬 네임 서버가 대응되는 IP 주소를 모를 경우 질의하게 되는 네임 서버로, 루트 도메인은 관장하여 질의에 대해 TLD 네임 서버의 IP 주소를 반환할 수 있음
  - TLD(최상위 도메인) 네임 서버: TLD를 관리하는 네임 서버로 질의에 대해 TLD의 하위 도메인 네임을 관리하는 네임 서버 주소를 반환할 수 있음. 하위 도메인을 관리하는 네임 서버는 마찬가지로 그보다 하위 도메인 네임을 관리하는 네임 서버 주소를 반환할 수 있음
  - 책임 네임 서버: 특정 도메인 영역을 관리하는 네임 서버로, 자신이 관리하는 도메인 영역의 질의에 대해서는 다른 네임 서버에 떠넘기지 않고 곧바로 답할 수 있는 네임 서버. 로컬 네임 서버가 마지막으로 질의하는 네임 서버임
- 로컬 네임 서버가 네임 서버에 질의하는 방법에는 재귀적 질의와 반복적 질의가 있음
  - 재귀적 질의: 클라이언트 - 로컬 네임 서버 -> 로컬 네임 서버 - 루트 네임 서버 -> 루트 네임 서버 - TLD 네임 서버 -> TLD 네임 서버 -> 다음 단계... 를 통해 최종 응답 결과를 역순으로 전달하는 방식
  - 반복적 질의: 로컬 네임 서버가 루트 네임 서버부터 책임 네임 서버까지, 다음으로 질의할 네임 서버의 주소를 응답 받아 재질의 하는 방식

### DNS 캐시

네임 서버들이 기존에 응답 받은 결과를 임시로 저장했다가 질의에 활용함

- DNS 캐시를 저장하는 용도로만 사용되는 서버가 있음
- DNS 캐시를 사용하면 더 짧은 시간에 IP 주소를 얻어낼 수 있음
- DNS 캐시의 경우 캐시될 수 있는 시간을 나타내는 TTL(Time to Live) 값과 함께 저장이 되어 시간이 지나면 사라짐

<br/><br/>

## 자원을 식별하는 URI

- 자원: 네트워크상의 메시지를 통해 주고받는 대상으로 오늘날 인터넷 환경을 이루는 대부분의 통신은 HTTP 를 기반으로 이루어져 HTTP 요청 메시지의 대상이라고도 함 (ex. HTML 파일, 이미지 파일, 동영상 파일, 텍스트 파일 등)
- URI(Uniform Resource Identifier): 자원을 식별할 수 있는 정보
  - URL(Uniform Resource Locator): 위치를 이용해 자원을 식별
  - URN(Uniform Resource Name): 이름을 이용해 자원을 식별

### URL

- URL과 URN 중 자원 식별에 더 많이 사용되는 방법
- URL 의 형태(foo://www.example.com:8042/over/there?name=ferret#nose)
  - scheme(foo): 자원에 접근하는 방법을 의미하고 일반적으로 사용할 프로토콜이 명시됨
  - authority(www.example.com:8042): 호스트를 특정할 수 있는 정보를 의미하고 IP 주소 또는 도메인 네임이 명시됨. 콜론(:) 뒤에 포트 번호를 덧붙일 수 있음
  - path(/over/there): 자원이 위치한 경로가 명시되고 슬래시(/)를 기준으로 계층적으로 표현됨
  - query(?name=ferret): 특정 단어를 검색한 결과, 내림차순으로 정렬한 결과 등 자원 위치 식별을 돕는 부분. 쿼리 문자열, 쿼리 파라미터로 불리며 물음표(?)로 시작하는 키=값 형태의 데이터로 앰퍼샌트(&)를 사용해 여러 쿼리 문자열을 연결할 수 있음
  - fragment(#nose): 자원의 한 조각을 가리키기 위한 정보 (ex.HTML 파일의 특정 부분으로 이동 등을 표현할 수 있음)

### URN

- URL 은 자원의 위치가 변하면 기존 URL 로는 자원을 식별할 수 없음
- URN 은 자원에 고유한 이름을 붙이기 때문에 자원의 위치와 무관함
- urn:isbn:0451450523 처럼 이름을 붙일 수 있고 이는 ISBN 이 0451450523 인 도서를 나타냄

## DNS 레코드 타입

- DNS 자원 레코드: 네임 서버가 저장하고 관리하는 정보
- 이름(호스트 이름, Record name)과 값(값/위치, Value)을 레코드 마다 저장하고 때로는 TTL을 설정하기도 함
- 유형(타입, Record Type) 또한 공통적으로 유지되는 정보로 레코드 유형이 달라지면 레코드 이름과 값의 의미가 달라짐
  - A: 특정 호스트에 대한 도메인 네임과 IPv4 주소와의 대응 관계
  - AAAA: 특정 호스트에 대한 도메인 네임과 IPv6 주소와의 대응 관계
  - CNAME: 호스트 네임에 대한 별칭 지정
  - NS: 특정 호스트의 IP 주소를 찾을 수 있는 네임 서버
  - MX: 해당 도메인과 연동되어 있는 메일 서버

<br/><br/><br/><br/>

# HTTP

## HTTP의 특성

HTTP는 응용 계층에서 정보를 주고받는 데 사용되는 프로토콜로 네 가지 주요 특성을 가짐

### 요청-응답 기반 프로토콜

- HTTP 는 클라이언트와 서버가 서로 HTTP 요청 메시지와 HTTP 응답 메시지를 주고받는 구조로 동작함
- HTTP 요청 메시지와 HTTP 응답 메시지는 메시지 형태가 다름

### 미디어 독립적 프로토콜

- HTTP 는 주고받을 자원의 특성과 무관하게 자원을 주고받을 수단(인터페이스)의 역할만 수행함. 따라서 HTML, JPEG 파일 등 다양한 종류의 자원을 주고받을 수 있음
- 미디어 타입(MIME 타입): HTTP에서 메시지로 주고받는 자원의 종류
- 미디어 타입은 슬래시를 기준으로 하는 타입/서브타입 형식으로 구성됨. 타입은 데이터의 유형, 서브타입은 주어진 타입에 대한 세부 유형을 나타냄. (ex. text/plain, image/png)
  - 별표 문자(\*)는 여러 미디어 타입을 통칭하기 위해 사용
  - 부가 설명을 위해 선택적으로 매개 변수를 사용하기도 함. 타입/서브타입;매개변수=값 형식으로 표현됨

### 스테이트리스 프로토콜

- 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않는, 스테이트리스 프로토콜임
- 클라이언트의 모든 HTTP 요청은 기본적으로 독립적인 요청으로 간주됨
- HTTP 는 확장성과 견고성을 목표로 하여 설계 됐음. 여러 대의 서버를 사용할 때 특정 클라이언트가 특정 서버에 종속되면, 서버에 문제가 생겼을 때 종속된 클라이언트들이 HTTP 통신 내역을 잃어버릴 수 있지만, 모든 요청을 독립적으로 처리하면 대처가 훨씬 용이함
- HTTP 가 스테이트리스 프로토콜이지만 서버가 클라이언트의 요청을 매번 처음보는 것처럼 동작하는 것은 아님

### 지속 연결 프로토콜

- HTTP 는 지속 발전 프로토콜인 만큼 여러 버전이 존재함 (ex. HTTP 1.1, HTTP 2.0 등)
- HTTP 는 TCP 상에서 동작하는데, HTTP 는 비연결형 프로토콜이지만 TCP 는 연결형 프로토콜임 (단 최신 버전은 HTTP 3.0은 UDP 상에서 동작함)
- 비지속 연결: 초기의 HTTP 버전(HTTP 1.0 이하)은 쓰리 웨이 핸드셰이크를 통해 TCP 연결을 수립한 후, 요청에 대한 응답을 받으면 연결을 종료하는 방식으로 동작했는데 이처럼 추가적인 요청-응답을 위해서는 다시 TCP 연결이 필요한 방식을 의미함
- 대중적인 버전(HTTP 1.1 이상)은 지속 연결이라는 기술을 제공하는데, keep-alive 라고 부름
- 지속 연결 기능을 지원하는 HTTP 는 비지속 연결에 비해 더 빠르게 여러 HTTP 요청과 응답을 처리할 수 있음

<br/><br/>

## HTTP 메시지 구조(HTTP 1.1 버전 기준)

- HTTP 메시지는 시작 라인, 필드 라인, 메시지 본문으로 이루어짐. 필드 라인은 없거나 여러 개 있을 수 있고 메시지 본문은 없을 수 있음.
- 필드 라인과 메시지 본문 사이에는 빈 줄바꿈이 있음
- 시작 라인: HTTP 메시지는 요청 메시지일 수도 있고 응답 메시지일 수도 있는데, 요청 메시지일 경우 **요청 라인** 이 되고 응답 메시지의 경우 **상태 라인** 이 됨
  - 요청 라인: `메서드 (공백) 요청 대상 (공백) HTTP 버전(줄바꿈)` 의 형식
    - 메서드: 클라이언트가 서버의 자원에 대해 수행할 작업의 종류를 나타냄 (ex. GET, POST, PUT, DELETE 등)
    - 요청 대상: HTTP 요청을 보낼 서버의 자원을 의미함. 보통 이곳에는 쿼리가 포함된 URI의 경로가 명시됨. (ex. /, /hello?q=world)
    - HTTP 버전: 사용된 HTTP 버전을 의미함. `HTTP/버전` 이라는 표기 방식을 따름
  - 상태 라인: `HTTP버전 (공백) 상태 코드 (공백) 이유 구문* (줄바꿈)`의 형식 (ex. HTTP/1.1 200 OK)
    - HTTP 버전: 사용된 HTTP 버전
    - 상태 코드: 요청에 대한 결과를 나타내는 세 자리 정수로 클라이언트가 요청이 어떻게 처리 되었는지를 판단할 수 있음
    - 이유 구문: 상태 코드에 대한 문자열 형태의 설명
- 필드 라인(헤더 라인): 0개 이상의 HTTP 헤더가 명시됨. 실제로는 메시지에 아주 다양한 헤더들이 사용되는 것이 일반적임
  - 각 헤더는 콜론(:) 을 기준으로 헤더 이름과 하나 이상의 헤더 값으로 구성됨 (ex. Host: www.example.com, Accept: text/html)
- 메시지 본문: 요청 혹은 응답 메시지에서 본문이 필요할 경우 사용됨

<br/><br/>

## HTTP 메서드

- API 문서를 통해 어떤 URL 로 어떤 요청을 받았을 때 서버가 어떻게 응답할지 정의함

### GET

특정 자원을 조회할 때 사용되는 메서드

- 요청 메시지

  ```
  GET /example-page HTTP/1.1
  Host: www.example.com
  Accept: *
  ```

- 응답 메시지

  ```
  HTTP/1.1 200 OK
  Content-Type: text/html
  Content-Length: 1234

  <!DOCKTYPE html>
  ..(이하 생략)
  ```

- 요청 메시지 본문을 포함시키는 것이 바람직하지 않음. 따라서 메시지 본문보다 쿼리 문자열이 사용되는 경우가 많음

### HEAD

GET 메서드와 동일한 역할을 하나 응답 메시지에 메시지 본문이 포함되지 않음

- 요청 메시지

  ```
  HEAD /example-page HTTP/1.1
  Host: www.example.com
  Accept: *
  ```

- 응답 메시지

  ```
  HTTP/1.1 200 OK
  Content-Type: text/html
  Content-Length: 1234
  ```

### POST

서버로 하여금 특정 작업을 처리하도록 요청하는 메서드

- 클라이언트가 서버에 새로운 자원을 생성하고자 할 때 사용
- 성공적으로 POST 요청이 처리되어 새로운 자원이 생성되면 서버는 응답 메시지의 Location 헤더를 통해 새로 생성된 자원의 위치를 클라이언트에게 알려줄 수 있음
- 요청 메시지

  ```
  POST /example-page HTTP/1.1
  Host: www.example.com
  Accept: *

  {
    "id": 1,
    "Title": "하이~",
    "Contents": "제곧내"
  }
  ```

- 응답 메시지

  ```
  HTTP/1.1 200 OK
  Content-Type: text/html
  Content-Length: 1234
  Date: Mon, 14 Oct 2024 16:35:00 PST
  Location: /posting/1
  ```

### 다른 메서드

- PUT: 덮어쓰기를 요청하는 메서드로 요청 자원이 없다면 메시지 본문으로 자원을 새롭게 생성하거나 이미 자원이 존재한다면 메시지 본문으로 자원을 완전히 대체함
- PATCH: PUT 이 완전한 대체에 가깝다면 PATCH 는 부분적 수정을 의미함
- DELETE: 특정 자원을 삭제하고 싶을 때 사용하는 메서드
- CONNECT: 자원에 대한 양방향 연결을 시작하는 메서드
- OPTIONS: 사용 가능한 메서드 등 통신 옵션을 확인하는 메서드
- TRACE: 자원에 대한 루프백 테스트를 수행하는 메서드

<br/><br/>

## HTTP 상태 코드

- 상태 코드는 요청에 대한 결과를 나타내는 세 자리 정수로 백의 자리 수를 기준으로 유형을 구분할 수 있음
- 상태 코드 유형
  - 100번대: 정보성 상태 코드
  - 200번대: 성공 상태 코드
  - 300번대: 리다이렉션 상태 코드
  - 400번대: 클라이언트 에러 상태 코드
  - 500번대: 서버 에러 상태 코드

### 200번대

| 상태코드 | 이유 구문  | 설명                                                    |
| -------- | ---------- | ------------------------------------------------------- |
| 200      | OK         | 요청이 성공했음                                         |
| 201      | Created    | 요청이 성공했으며, 새로운 자원이 생성되었음             |
| 202      | Accepted   | 요청을 잘 받았으나, 아직 요청한 작업을 끝내지 않았음    |
| 204      | No Content | 요청이 성공했지만, 메시지 본문으로 표시할 데이터가 없음 |

### 300번대

- 300번대 상태 코드는 리다이렉션과 관련된 상태 코드
- 리다이렉션: 클라이언트가 요청한 자원이 다른 곳에 있을 때 클라이언트의 요청을 다른 곳으로 이동 시키는 것
- 리다이렉션의 유형은 영구적인 리다이렉션과 일시적인 리다이렉션으로 구분됨
  - 영구적인 리다이렉션: 자원이 완전히 새로운 곳으로 이동하여 경로가 영구적으로 재지정되는 것을 의미함
  - 일시적인 리다이렉션: 자원의 위치가 임시로 변경되었거나 임시로 사용할 URL이 필요한 경우에 사용됨

| 상태 코드 | 이유 구문          | 설명                                                                  |
| --------- | ------------------ | --------------------------------------------------------------------- |
| 301       | Moved Permanently  | 영구적 리다이렉션: 재요청 메서드 변경될 수 있음                       |
| 308       | Permanent Redirect | 영구적 리다이렉션: 재요청 메서드 변경되지 않음                        |
| 302       | Found              | 일시적 리다이렉션: 재요청 메서드 변경될 수 있음                       |
| 303       | See Other          | 일시적 리다이렉션: 재요청 메서드 GET 으로 변경                        |
| 307       | Temporary Redirect | 일시적 리다이렉션: 재요청 메서드 변경되지 않음                        |
| 304       | Not Modified       | 자원이 변경되지 않았음을 의미하는 상태 코드로, 캐시와 관련된 상태코드 |

### 400번대

- 클라이언트에 의한 에러가 있음을 알려주는 상태 코드
- 서버가 처리할 수 없는 형태로 요청을 보냈거나, 존재하지 않는 자원에 대해 요청을 보내는 경우가 해당함

| 상태 코드 | 이유 구문          | 설명                                                |
| --------- | ------------------ | --------------------------------------------------- |
| 400       | Bad Request        | 클라이언트의 요청이 잘못되었음                      |
| 401       | Unauthorized       | 요청한 자원에 대한 유효한 인증이 없음               |
| 403       | Forbidden          | 요청이 서버에 의해 거부됨(ex.접근 권한이 없을 경우) |
| 404       | Not Found          | 요청받은 자원을 찾을 수 없음                        |
| 405       | Method Not allowed | 요청한 메서드를 지원하지 않음                       |

- 401로 응답할 때는 WWW-Authenticate 라는 헤더를 통해 인증 방법을 알려주어야 함
- 인증이란 자신이 누구인지 증명하는 것이고, 권한 부여는 인증된 주체에게 작업을 허용하는 것으로 401 과 403의 차이점이 있음

### 500번대

- 클라이언트가 올바르게 요청을 보냈을지라도 발생할 수 있는 서버 에러에 대한 상태 코드

| 상태 코드 | 이유 구문             | 설명                                                 |
| --------- | --------------------- | ---------------------------------------------------- |
| 500       | internal Server Error | 요청을 처리할 수 없음                                |
| 502       | Bad Gateway           | 중간 서버의 통신 오류                                |
| 503       | Service Unavailable   | 현재는 요청을 처리할 수 없으나 추후 가능할 수도 있음 |

- 500은 서버 내 에러를 통칭하기도 함

<br/><br/>

## HTTP 의 발전

1. HTTP/0.9
   <br/>지금은 거의 사용하지 않는 초창기 HTTP 버전으로 사용가능한 메서드가 GET뿐이고, 요청 메시지가 한 줄로 구성되어 있음. 헤더가 지원되지 않아 기능과 성능 면에서 아주 제한적이었음
2. HTTP/1.0
   <br/>HEAD, POST 와 같은 메서드가 도입되고 헤더가 지원되기 시작함. 공식저으로는 지원 연결을 지원하지 않았음
3. HTTP/1.1
   <br/>지속 연결이 공식적으로 지원됨
   <br/>특정 요청에 대한 응답이 수신되기 전에 다음 요청을 보낼 수 있는 파이프라이닝 기능과 콘텐츠 협상 기능등 다양한 편의 기능 및 사용 가능한 헤더가 추가됨
   <br/>오늘까지 널리 사용
4. HTTP/2.0
   <br/>HTTP/1.1의 효율과 성능을 높이기위해 보완하고 개선한 버전
   <br/>송수신 효율을 높이기 위해 헤더를 압축하여 전송하고 텍스트 기반 메시지를 송수신한 이전 버전과 달리 바이너리 데이터 기반의 메시지를 송수신함
   <br/>클라이언트의 요청없이도 미래에 필요할 것으로 예상되는 자원을 미리 전송해주는 서버 푸시 기능을 제공함
   <br/>멀티플렉싱 기법을 도입해 HOL 블로킹 문제 완화한 버전
5. HTTP/3.0
   <br/>이전 버전들이 TCP를 기반으로 동작한 것과 달리 UDP를 기반으로 구현된 QUIC(Quick UDP Internet Connections) 프로토콜을 기반으로 동작함
   <br/>UDP가 TCP에 비해 상대적으로 빠르기 때문에 속도 측면에서 큰 개선이 이루어짐

- HOL 블로킹: 같은 큐테 대기하며 순차저으로 처리되는 여러 패킷이 있을 때, 첫 번째 패킷의 처리 지연으로 인해 나머지 패킷들의 처리도 모두 지연되는 문제 상황
- 멀티플렉싱: 여러 스트림을 이용해 병렬적으로 메시지를 주고받는 기술. 요청과 응답은 하나의 스트림에서 이루어지되 스트림을 여러 개 활용하고, 스트림 별로 독립적인 송수신이 가능하며, 스트림별 메시지들은 꼭 일정한 순서를 유지할 필요가 없음.

<br/><br/><br/><br/>

# HTTP 헤더와 HTTP 기반 기술

## HTTP 헤더

### 요청 시 활용되는 HTTP 헤더

- `Host`: 요청을 보낼 호스트를 나타내는 헤더. 주로 도메인 네임으로 명시되며 포트 번호가 포함되어 있을 수 있음
- `User-Agent`: 유저 에이전트는 웹 브라우저와 같이 HTTP 요청을 시작하는 클라이언트 측의 프로그램으로 헤더에는 클라이언트 프로그램과 관련된 운영체제, 브라우저 종류 및 버전, 렌더링 엔진 등의 정보가 포함됨
- `Referer`: 클라이언트가 요청을 보낼 때 머무르고 있던 URL 이 명시되며 개발 시 아주 유용한 헤더.(Referrer가 영문법적으로 맞는 표현이지만 개발 당시 오타로 인해 Referer가 됨)
- `Authorization`: 클라이언트의 인증 정보를 담는 헤더. `Authorization <type> <credentials>` 와 같이 명시됨. 인증 타입의 종류는 다양하지만 가장 기본적인 인증 타입은 Basic 으로 username:password 와 같이 아이디와 비밀번호를 콜론을 이용해 합친 뒤, 이를 Base64 인코딩한 값을 인증 정보로 삼는 방식임.

### 응답 시 활용되는 HTTP 헤더

- `Server`: 요청ㅇ르 처리하는 서버 측의 소프트웨어와 관련된 정보를 명시
- `Allow`: 클라이언트에게 허용된 HTTP 메서드 목록을 알려 주기 위해 사용됨. 405(Mothod Not Allowed)를 응답하는 메시지에서 Allow 헤더가 함께 사용됨.
- `Retry-After`: 현재 요청을 처리할 수 없지만 추후 가능할 수도 있음을 의미하는 503(Server Unavailable)과 함께 쓰일 수 있는 헤더로 자원을 사용할 수 있는 날짜 혹은 시각을 나타내며 또는 몇 초 뒤에 사용이 가능한지를 나타냄
- `Location`: 클라이언트에게 자원의 위치를 알려주기 위해 사용하는 헤더로 주로 리다이렉션이 발생했을 때나 새로운 자원이 생성되었을 때 사용됨.
- `WWW-Authenticate`: 401(Unauthorized)과 함께 사용되는 헤더로 자원에 접근하기 위한 인증 방식을 설명하는 헤더. 보안 영역을 함께 알려주거나 인증에 사용될 문자집합도 알려줄 수 있음. (ex. WWW-Authenticate: Basic real="Access to enginnering site", charset="UTF-8")
  - realm: 보안이 적용될 영역으로 영역이 달라지면 같은 서버가 제공하는 자원일지라도 요구되는 권한도 달라질 수 있기 때문에 사용
  - HTTP 인증 수행과정: 인증되지 않은 클라이언트가 GET 요청 메시지 전송 -> 서버가 401 상태 코드와 함께 WWW-Authenticate 헤더를 통해 인증 방식 알림 -> 클라이언트는 사용자로부터 인증 정보 전달 받음 -> '사용자:비밀번호'를 Base64 인코딩한 값을 인증 정보로 삼은 Authorization 헤더를 통해 다시 GET -> 서버가 인증 정보 확인 -> 인증 정보가 유효하면 200, 인증되지 않으면 401 로 응답

### 요청과 응답 모두에서 사용되는 HTTP 헤더

- `Date`: 메시지가 생성된 날짜와 시각
- `Connection`: `keep-alive`를 사용해 지속 연결을 희망함을 알릴 수 있고 `close`를 통해 연결 종료를 희망함을 알릴 수 있음. 이외에도 다양한 값들이 명시될 수 있지만 가장 대표적으로는 둘이 사용됨
- `Content-Length`: 본문의 바이트 단위 크기(길이)
- `Content-Type`, `Content-Language`, `Content-Encoding`: 메시지 본문의 표현 방식을 설명하는 헤더.
  - Type: 미디어 타입
  - Language: 메시지 본문의 자연어를 명시하며 언어 태그를 하이픈(-)으로 구분된 구조를 가짐. <첫 번째 서브 태그>-<두 번째 서브태그>-<세 번째 서브태그> 식으로 구성 (ex. en-US, ko-KR) 첫 번째 서브 태그는 언어, 두 번째 서브 태그는 국가 코드를 명시함
  - Encoding: 메시지 본문을 압축하거나 변환한 방식이 명시됨. 여러 인코딩이 사용되었을 경우 적용된 순서대로 명시

<br/><br/>

## 캐시

불필요한 대역폭 낭비와 응답 지연을 방지하기 위해 정보의 사본을 임시로 저장하는 기술

- 캐시 저장 위치
  - 개인 전용 캐시: 웹 브라우저에 저장
  - 공용 캐시: 클라이언트와 서버 사이에 위치한 중간 서버에 저장
- 캐시를 할 경우 원본 데이터가 변경되는 상황에 대비해야 함
- 캐시 신선도(cache freshness)를 통해 캐시된 사본 데이터가 얼마나 최신 원본 데이터와 유사한지를 표현함
- 캐시된 데이터에 유효 기간을 설정하여 기간이 만료되었다면 원본 데이터를 다시 요청하는 방식으로 캐시 신선도를 유지할 수 있음
- 캐시 데이터에 유효 기간을 부여하는 방법으로 응답 메시지의 `Expires` 헤더(날짜)와 `Cache-Control` 헤더의 Max-Age 값(초)를 사용할 수 있음
- 캐시의 유효 기간이 만료되었더라도 원 본 데이터가 변하지 않았다면 서버는 굳이 같은 자원을 전송해줄 필요가 없고 유효기간을 연정하여 이용하면 됨
- 캐시 신선도 재검사: 캐시의 유효 기간 만료 시, 클라이언트가 캐시된 자원이 여전히 신선한지, 여전히 최신 상태의 정보인지 재검사해야 함
  - 날짜를 기반으로 서버에게 물어보는 방법: `If-Modified-Since` 헤더의 값으로 특정 시점(날짜와 시각)을 명시하여 서버에게 특정 시점 이후로 원본 데이터의 변경이 있었는지 물어보고, 원본 변경이 있었다면 새 자원으로 응답하도록 서버에게 요청하는 방식
    - 요청받은 자원이 변경됨: 200(OK) 와 함께 새로운 자원 반환
    - 요청받은 자원이 변경되지 않음: 304(Not Modified) 를 통해 클라이언트에게 자원이 변경되지 않았음을 알림. 이 경우 클라이언트는 캐시된 자원 이용 가능. Last-Modified 헤더를 통해 특정 자원이 마지막으로 수정된 시점을 알려줄 수 있음.
    - 요청받은 자원이 삭제됨: 404(Not Found) 로 요청한 자원이 존재하지 않음을 알림
  - 엔티티 태그(Etag)를 기반으로 서버에게 물어보는 방법: 엔티티 태그는 자원의 버전을 식별하기 위한 정보로 유의미한 변겅 사항이 있을 경우 버전이 변경됨. 클라이언트는 `If-Non-Match`를 이용하여 Etag 와 일치하는 자원이 서버에 있는지 서버에 질문하고 변경되었을 때만 새 자원으로 응답받을 수 있음 - 요청받은 자원이 변경됨(Etag 값 변경): 200(OK) 와 함께 새로운 자원 반환 - 요청받은 자원이 변경되지 않았음(Etag 값 동일): 304(Not Modified) 로 메시지 본문 없이 응답 - 요청받은 자원이 삭제됨: 404(Not Found) 로 응답

<br/><br/>

## 쿠키

서버에서 생성되어 클라이언트 측에 저장되는 데이터로, 상태를 유지하지 않는 HTTP 의 특성을 보완하기 위한 수단

- 이름, 값 쌍의 형태를 띠고 있음
- 적용 범위와 만료 기간등 다양한 속성을 가질 수 있음
- 서버는 쿠키를 생성하여 클라이언트에게 전송하고, 클라이언트는 전달받은 쿠키를 저장해 두었다가 추후 동일한 서버에 보내는 요청 메시지에 쿠키를 포함하여 전송함
- 서버는 쿠키 정보를 참고해 두 개의 요청이 같은 클라이언트에서 왔는지, 로그인 상태를 유지하고 있는지 등을 알 수 있음
- 쿠키를 통해 전달되는 정보에는 세션 아이디가 있는데, 세션 인증에서 사용됨
  <br/>세션 인증 과정
  <br/>클라이언트->서버: 인증 정보 전송
  <br/>서버->클라이언트: 인증정보가 올바르다면 서버가 세션 아이디를 생성해 전송
  <br/>서버: 세션 아이디를 데이터베이스 등에 저장
  <br/>클라이언트->서버: 추후 요청을 보낼 때 쿠키 내에 세션 아이디를 포함하여 전송
  <br/>서버: 쿠키 속 세션 아이디와 저장된 세션 아이디를 비교하여 클라이언트 식별
- 서버는 응답 메시지의 `Set-Cookie` 헤더, 클라이언트는 요청 메시지의 `Cookie` 헤더를 이용하여 쿠키를 전달함
  - `Set-Cookie` 헤더를 통해 쿠키의 이름, 값과 더불어 세미콜론으로 구분되는 속성들을 전달할 수 있음 (ex. Set-Cookie: 이름=값; 속성1)
  - `Cookie`: 쿠키 값을 여러 개 전달해야할 경우 세미 콜론을 사용하여 여러 쿠키의 이름-값을 나타냄 (ex. Cookie: 이름=값; 이름=값)
- 쿠키는 브라우저에서 저장되고 관리됨
- 쿠키는 사용 가능한 도메인이 정해져 있고, 이는 Set-Cookie 헤더의 'domain' 속성으로 정해짐
- 같은 도메인이라도 경로별로 쿠키를 구분하여 사용하고 싶을 땐 path 값으로 쿠키가 적용될 경로를 명시함 (ex. Set-Cookie: name=minji; path=/lectures)
- 쿠키마다 보통 유효 기간이 정해져 있고 Expires, Max-Age 를 통해 쿠키 만료 시점을 의미함. Expires로 명시된 시점이 지나거나 Max-Age 로 명시된 유효 기간이 지나면 해당 쿠키는 삭제되어 전달되지 않음
- 쿠키 정보는 쉽게 노출되거나 조작될 수 있으므로 보안에 취약하고 이를 보완하기 위해 Secure, HttpOnly 라는 속성을 둠
  - Secure: HTTPS 프로토콜이 사용되는 경우에만 쿠키를 전송하도록 하는 속성
  - HttpOnly: HTTP 송수신을 통해서만 쿠키를 이용하도록 제한하는 속성. 쿠키 관련 데이터는 자바스크립트를 통해서도 접근 가능하므로 자바스크립트로 쿠키를 중간에 가로채거나 위변조하지 못하도록 하는 속성

### 웹 스토리지: 로컬 스토리지와 세션 스토리지

클라이언트가 저장하고 클라이언트의 상태를 추측할 수 있는 키-값 형태의 정보

- 쿠키가 서버로 자동 전송되는 것과 달리, 웹 스토리지 값은 서버로 자동 전송되지 않고 필요할 때 조회할 수 있음
- 세션 스토리지: 세션이 유지되는 동안 유지되는 정보
- 로컬 스토리지: 별도로 삭제하지 않는 한 영구적으로 저장 가능한 정보

### 콘텐츠 협상과 표현

- 콘텐츠 협상: 같은 URI에 대해 가장 적합한 자원에 형태를 제공하는 메커니즘 (ex. 영어로 요청하면 영어로 된 형태를 제공하는 것)
- 표현: 송수신 가능한 자원의 형태
- `Accept`: 선호하는 미디어 타입을 나타냄
- `Accept-Language`: 선호하는 언어를 나타냄
- `Accept-Charset`, `Accept-Encoding`: 선호하는 문자 인코딩과 압축 방식
- 선호도에 우선순위를 반영할 수 있음. 콘텐츠 협상 관련 헤더의 q(Quality Value의 약자) 값을 통해 특정 표현을 얼마나 선호하는지를 나타낼 수 있음. 생략될 경우 1을 의미하고 범위는 0~1이며, 값이 클수록 우선순위가 높음.
