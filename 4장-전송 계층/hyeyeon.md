# 전송 계층 개요: ip의 한계와 포트

네트워크 계층의 IP에서 한계가 있는 신뢰할 수 있는 통신과 연결형 통신이 가능하게 함 (전송 게층이 네트워크 계층의 한계를 극복)
포트번호를 통해 응용 계층의 애플리케이션 프로세스들을 식별하는 역할을 수행한다.

## 신뢰할 수 없는 통신과 비연결형 통신

신뢰 할 수 없는 통신은 IP 프로토콜이 패킷이 수신지까지 제대로 전송되었다는 보장을 하지 않는 특징을 일컫는다. - 최선형 전달을 함 (데이터 손상, 중복 패킷 확인 X, 재전송X, 순서대로 도착보장 X)

비연결 통신 : 송수신 호스트 간에 사전 연결 수립 작업X, 그저 보내기만 함

-> 성능을 위해 안정성을 포기

## IP의 한계를 보완하는 전송계층

### 1. 전송 계층은 연결형 통신을 가능하게 한다.

TCP는 회선 교환 방식을 사용한다. (호스트 간에 메시지를 주고받기 전에 호스트 사이에 메시지 전송로를 설정, 해당 전송로를 이용해서 메시지를 주고받는 방식이다.)

### 2. 전송계층은 신뢰성있는 통신을 가능하게 함

TCP는 패킷이 수신지까지 올바른 순서대로 확실히 전달되는 것을 보장하기 위해 재전송을 통한 오류 제어, 흐름 제어, 혼잡 제어 등 다양한 기능들을 제공합니다.
한편 성능을 위해 비연결 프로토콜이 필요할 때는 UDP 방식을 사용 (신뢰할 수 없는 통신, 비연결 통신)

## 응용 계층과 연결 다리, 포트

포트를 통해 응용 계층의 애플리케이션을 식별함으로써 응용 계층과의 연결 다리 역할을 수행한다.

### 포트

패킷의 최종 수신 대상은 특정 애플리케이션 프로세스이다.
패킷이 실행 중인 특정 애플리케이션까지 전달되려면 패킷에 특정 애플리케이션을 식별할 수 있는 정보가 포함되어 있어야 합나디, 이러한 정보를 포트라고 합니다.

### 포트의 분류

수신지 포트와 송신지 프트 번호를 통해 송수신지 호스트의 애플리케이션을 식별합니다.

|       포트 종류       | 포트 번호 범위 |                                         예시                                         |
| :-------------------: | :------------: | :----------------------------------------------------------------------------------: |
|    잘 알려진 포트     |     0~1023     | (20,21 FTP), (22 SSH), (23 TELNET), (53 DNS), (67, 68 DHCP), (80, HTTP), (443 HTTPS) |
|      등록된 포트      |   1024~49151   |     (1194 OpenVPN), (1433 MS SQL 서버), (3306 MySQL), (6379 Redis), (8080 HTTP)      |
| 동적(사설, 임시) 포트 |  49152~65535   |                                                                                      |

서버는 프로그램의 포트 번호는 잘 알려진 포트와 등록된 포트로 동작하는 경우가 많습니다.
단면, 클라이언트는 동적 포트 중에서 임의 번호가 할당되는 경우가 많다.
ex. 웹 브라우저에서 특정 웹 사이트에 접속하는 상황 시, 브라우저와 서버가 서로 패킷을 주고 받는다. 이때 웹 브라우저 프로그램에는 동적 포트 내의 임의 포트 번호가 자동으로 할당된다.

IP주소와 포트 번호에 대한 정보를 주어지면 특정 호스트에서 실행 중인 특정 애플리케이션 프로세스을 식별할 수 있습니다.
그래서 포트 번호는 IP주소:포트 번호 형식으로 IP주소와 함께 표기된다.

## 포트 기반 NAT

IP주소를 변환하는 기술이며, 사설 IP주소와 공인 IP 주소를 변화하는 데 사용된다.
이러한 변환을 위해 주로 사용되는 것이 NAT 변환 테이블이다.

### NAT 변환 테이블

변환의 대상이 되는 IP주소 쌍이 명시되어 있다.
오늘날 대중적으로 활용되는 NAT은 사설 IP와 공인 IP가 1:1로 매칭시키지 않고 여러 사설 IP가 그 보다 적은 수의 공인 IP와 연결됨

여러 사설 IP를 하나의 공인 IP로 변환하기 위해 포트가 사용됨

### NAPT

포트 기반의 NAT
NAPT는 포트를 활용해 하나의 공인 IP주소를 여러 사설IP가 공유할 수 있도록 하는 NAT의 일종
NAT 테이블에 변활할 IP주소 쌍과 더불어 포트 번호도 함께 기록하고, 변환합니다.

네트워크 외부에서 사용할 IP주소가 같더라도 포트 번호가 다르면 네트워크 내부의 호스트를 특정할 수 있기에 적은수의 공인 IP로 다수의 사설 IP를 연결할 수 있다.
이러한 점에서 NAPT는 공인 IP주소 수 부족 문제를 개선한 기술로 간주됨

### 포트 포워딩

네트워크 내 특정 호스트에 IP주소와 포트 번호를 미리 할당하고, 해당 IP주소:포트 번호로써 해당 호스트에게 패킷을 전달하는 기능입니다.

네트워크 내에 여러 사설 IP들은 하나의 공인 IP주소를 공유하고 있습니다. 이런 경우 처음 패킷을 보내는 네트워크 외부 호스 입장에서 어떤 IP주소를 수신지 주소로 삼을지 결정하기 어려울 수 있다. 이때 사용되는 것이 포트 포워딩이다.

특정 IP주소와 포트 번호 쌍을 특정 호스트에게 할당한 뒤, 외부에서 통신을 시작할 호스트에게 해당 접속 정보(IP:포트)을 알려주면 됩니다.
그럼 네트워크 외부 호스트는 그 IP주소:포트로 통신을 시작할 수 있습니다.

이처럼 포트 포워딩은 주로 네트워크 외부에서 네트워크 내부로 통신을 시작할 떄, 네트워크 내부의 서버를 외부에서 접속할 수 있도록 접속 정보를 공개하기 위해 자주 사용한다.

- 내부 -> 외부 하기 전에
- 미리 포트포워딩(임의로 IP:포트 연결)을 하여 임의로 NAPT에 기록
- 그 후, 외부 -> 내부 통신할 때 NAPT를 보고 내부와 연결한다.

그니깐 즉, 포트포워딩한 정보는 정적 NAT로 비휘발성 메모리에 저장이 되지만 통신할 때 내부-> 외부에서 갈때 임의로 지정해서 가는 걸 동적 NAT이라고 하

### ICMP

IP의 신뢰할 수 없는 전송 특성과 비연결형 전송 특성을 보완하기 위한 네트워크 계층의 프로토콜 ICMP가 있음
ICMP는 IP 패킷의 전송과정에 대한 피드백 메시지(ICMP 메시지)를 얻기 위해 사용하는 프로토콜

ICMP 메시지는 타입과 코드로 정의합니다. 타입과 코드는 ICMP 패킷 헤더에 포함되어 있는 정보입니다.
ICMP 패킷 헤더의 타입 필드에는 ICMP 메세지의 유형이 번호로 명시되고, 코드 필드에는 구체적인 메시지 내용이 번호로 명시됩니다.

종류

1. 전송 과정에서 발생한 문제 상황에 대한 오류 보고 (ICMP 메시지 타입으로는 수신지 도달 불가와 시간 초과)
2. 네트워크에 대한 진단 정보(네트워크상의 정보 제공)가 있습니다.

# TCP와 UDP

## TCP 통신 단계와 세그먼트 구조

연결 수립 -> 데이터 송수신 -> 연결 종료

- TCP는 통신 하기 전에 연결을 수립하고 통신이 끝나면 연결을 종료합니다.
- 데이터 송수신 과정에서 재전송을 통한 오류 제어, 흐름 제어, 혼잡 제어 등의 기능 제공

MSS는 TCP로 전송할 수 있는 최대 페이로드 크기, MSS이 크기를 고려할 때 TCP 헤더 크기는 제외한다.

세그먼트 헤더 구조
| 이더넷 헤더 | IP 헤더 | TCP 헤더 | 페이로드 | FCS |

- 송신지 포트, 수신지 포트
- 순서 번호
- 확인 응답 번호 : 상대 호스트가 보낸 세그먼트에 대한 응답, 다음으로 수신하기를 기대하는 순서 번호
- 제어 비트
- 윈도우

### 제어 비트

- ACK: 세그먼트의 승인을 나타내기 위한 비트
- SYN: 연결을 수립하기 위한 비트
- FIN: 연결을 종료하기 위한 비트

### 순서 번호와 확인 응답 번호

TCP의 신뢰성을 보장하기 위해 사용되는 중요한 필드

순서 번호 : 세그머트의 올바른 송수신 순서를 보장하기 위한 번호, 세그먼트 데이터의 첫 바이트에 부여되는 번호
확인 응답 번호: 순서 번호에 대한 응답, 확인 응답 번호는 수신자가 다음으로 받기 기대하버호

## TCP 연결 수립과 종료

### 연결 수립: 쓰리 웨이 핸드 쉐이크

| 송수신 방향 | 세그먼트         | 세그먼트에 포함된 주요 정보                                                                                                  | 비유                 |
| ----------- | ---------------- | ---------------------------------------------------------------------------------------------------------------------------- | -------------------- |
| A->B        | SYN 세그먼트     | - 호스트 A의 초기 순서 번호</br> 1로 설정된 SYN비트                                                                          | 연결 시작            |
| B->A        | SYN+ACK 세그먼트 | 호스트 B의 초기 순서 번호</br>호스트 A가 잔송한 세그먼트에 대한 확인 응답 번호</br>1로 설정된 SYN비트</br>1로 설정된 ACK비트 | 확인했으니 연결 ㄱㄱ |
| A->B        | ACK 세그먼트     | 호스트A의 다음 순서 번호</br> 호스트 B가 전송한 세그먼트에 대한 확인 응답 번호</br>1로 설정된 ACK비트                        | 확인                 |

처음 연결 시작하는 호스트의 연결 수립 과정을 액티브 오픈이라고 한다.
연결 요청을 받고 나서 요청에 따라 연결을 수립 과정을 패시브 오픈.

### 연결 종료

TCP가 연결을 종료하는 과정은 송수신 호스트가 각자 한 번씩 FIN과 ACK를 주고 받으며 이ㅜ어짐
액티브 클로즈 : 먼저 연결을 종료하려는 호스트에 의해 수행
패사브 클로즈 : 연결 종료 요청을 받아들이는 호스트에 의해 수행됩니다,

## TCP 상태

TCP는 연결형 통신과 신뢰할 수 있는 통신을 유지하기 위해 다양한 상태를 저장한다, 이를 스테이트폴 프로토콜

### 연결이 수립되지 않은 상태

연결이 수립이 이루어지기 전의 호스트는 주로 CLOSED나 LISTEN 상태를 유지하고 있습니다.

- CLOSED : 아무런 연결이 없는 상태
- LISTEN : 연결 대시 상태 (SYN 세그먼트를 기다리는 상태)

### 연결 수립 상태

- SYN-SENT: 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤에 그에 대한 응답인 SYN + ACK 세그먼트를 기다리는 상태
- SYN-RECEEIVED: 패시브 오픈 호스트가 SYN + ACK 세그먼트를 보낸 뒤 그에 대한 ACK 세그먼트를 기다리는 상태
- ESTABLISHED: 연결이 확립되었음을 나타내는 상태, 송수신할 수 있는 상태를 의미

### 연결 종료 상태

- FIN-WAIT-1: FIN 세그먼트로서 연결 종료 요청을 보낸 액티브 클로즈 호스트
- CLOSE-WAIT: FIN 세그먼트를 받은 패시브 클로즈 호스트가 그에 대한 응답으로 ACK 세그먼트를 보낸 후 대기하는 상태
- FIN-WAIT-2: ACK 받은 상태로 FIN를 기다리는 상태
- LAST-ACK: FIN을 전송 후 이에 대한 ACK를 기다리는 중
- TIME-WAIT: 액티브 클로즈 호스트가 FIN 세그먼트 수신한 뒤, 이에 대한 ACK 세그먼트를 전송한 뒤 접어드는 상태

## UDP 데이터 그램 구조

비연결형 통신을 수행하는 신뢰할 수 없는 프로토콜입니다.

- 데이터 송수신 과정에서 재전송을 통한 오류 제어, 흐름 제어, 혼잡 제어 등의 기능을 제공하지 않는다.
- TCP 처럼 상태를 유지하지도 않는다. 스테이트리스 프로토콜의 일종이라고 한다

헤더 구성

1. 송신지 포트
2. 수신지 포트
3. 길이: 헤더를 포함한 UDP 데이터 그램의 바이트가 담김니다.
4. 체크섬: 데이터그램 전송과정에서 오류가 발생했는지 검사하기 위한 필드

# TCP의 오류 흐름 혼잡 제어

TCP는 재전송을 기반으로 다양한 오류를 제어하고, 흐름제어를 통해 처리할 수 있을 만큼 데이터만을 주고받으며, 혼잡 제어를 통해 네트워크가 혼잡한 정도에 따라 전송량을 조절합니다.

## 오류 제어 : 재전송 기법

### 오류 검출과 재전송

채그섬만으로 신뢰성을 보장하기 부족하다.
체크섬은 세그먼트의 훼손 여부만 나타내지(잘못되면 그냥 파기하기에), 송신 호스트가 세그먼트 전송과정에 문제가 있다는 것을 인지할 수 없습니다.

TCP가 신뢰성을 제대로 보장하려면

1. 송신 호스트가 송신한 세그먼트에 문제가 발생했음을 인지
2. 오류를 감지하게 되면 해당 세그먼트를 재전송할 수 있어야 한다.

#### 오류및 재전송하는 상황 1. 중복된 ACK 세그먼트를 수신했을 때

TCP는 중복된 ACK 세그먼트를 수신했을 때 오류가 생겼음을 감지합니다.
주고 받을 때 순서의 번호를 보내고, 이에 대한 ACK세그먼트를 받은 뒤 다음 순서를 보내는 세그먼트를 보내기에
세그먼트의 순서 번호 중에서 일부가 누락되었다면 중복된 ACK를 전송하게 된다.

#### 오류및 재전송하는 상황 2. 중복된 ACK 세그먼트를 수신했을 때

TCP는 타임아웃이 발생하면 문제가 생겼음을 인지합니다.
TCP 세그먼트를 송신하는 호스트는 모두 재전송 타이머라는 값을 유지합니다,
호스트가 세그먼트를 전송할 때마다 재전송 타이머를 시작하게 되는데, 이 타이머의 카운트 다운이 끝난 상황을 타임아웃이라고 합니다.
타임 아웃이 발생할 때까지 ACK세그먼트를 받지 못하면 세그먼트가 상대 호스트에게 정상적으로 도착하지 않았다고 간주하여 세그먼트를 재전송합니다.

#### ARQ: 재전송 기법

수신 호스트의 답변과 타임아웃 발생을 토대로 문제를 진단하고, 문제가 생긴 메시지를 재 전송함으로써 신뢰성을 확보하는 방식을 ARQ라고 합니다,
ARQ의 종류는

1. stop-and-ait ARQ : 제대로 전달했음을 확인하기 전까지 새로운 메시지를 보내지 않는 방식 (높은 신뢰성 보장, 네트워크 이용 효율이 낮음-> 성능 저하)
2. go-back-n ARQ : 각 세그먼트에 대한 ACK 세그먼트가 도착하기 전이라도 여러 세그먼트를 보낼 수 있어야 한다. (파이프라이닝), 잘못된건 해당 세그먼트부터 다시 전송하는 방식, 그럼 그외 모든 세그먼트를 전부 파괴함 ( N번까지의 확인응답이라는 점에 누적확인 응답이라고 합니다.)
3. selective repeat ARQ : 선택적으로 재전송하는 방식, 잘못된건만 보내는 방식

## 흐름 제어 : 슬라이딩 윈도우

호스트가 한 번에 받아서 처리할 수 있는 세그먼트 양에는 한계가 있기에 흐름을 제어해야한다.

수신 버퍼 : 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시로 저장되는 공간, 그래서 이 크기가 넘지 않더록 보내야함
버터 오버플로 : 정해진 양에서 더 많은 데이터를 저장할려고 할 때 발생

TCP의 흐름 제어란 이러한 문제 상황을 방지하고자 송신 호스트가 수신 호스트의 처리속도를 고려하여 송수신 속도를 균일하게 유지하는 것을 의미

무작정 무한한 데이터를 연속해서 보낼 수 없기에

슬라이딩 윈도우를 사용한다, 윈도우란 송신 호스트가 파이프라이닝을 할 수 있는 최대량을 의미

## 혼잡 제어

혼잡: 많은 트래픽으로 인해 패킷의 처리 속도가 늦어지거나 유실될 우려가 있는 네트워크 상황을 의미

혼잡 제어란 이와 같은 혼잡을 제어하기 위한 기능. 흐름 제어의 주체가 수신 호스트라면 혼잡 제어의 주제는 송신 호스트입니다, 혼잡 제어를 수행하는 송신 호스트는 네트워크 혼잡도를 판단하고 혼잡한 정도에 맞춰 유동적으로 전송량을 조절하여 전송합니다.

혼자바 제어를 이해하려면 먼저 혼잡 위도우를 알아야한다, 혼잡 윈도우는 혼잡 없이 전송할 수 있을 법한 데이터양을 의미합니다.
혼잡 윈도우 크기는 혼잡 제어 알고리즘을 통해 결정

AIMD : 혼잡이 감지되지 않는다면 혼잡 윈도우를 RTT마다 1씩 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 동작을 반복하는 알고리즘이다.

기본 알고리즘으로 이만트로 충분하지 않다. 그래서 더 정교한 알고라즘 필요

1. 느린 시작
   혼잡 윈도우를 1부터 시작해 문제없이 수신된 ACK 세그먼트 당 하나씩 증가시키는 방식. RTT마다 2배씩 지수적으로 증가 (그래서 초기에는 느림), 혼잡해지는 상황 느린 시작 임계치 이상이되거나, 타임아웃이 발생하거나, 세 번의 중복된 ACK 세그먼트가 발생하여 혼잡이 감지되면 다음 세 가지 방법 중 하나를 선택하게 된다.

   - 타임 아웃 발생 : 감지된 시점의 혼잡 윈도우 값의 절반으로 초기화 한 뒤 느린 시작 재개
   - 혼잡 윈도우 >= 느린 시작 임계치 : 느린 시작 종료, 혼잡 윈도를 절반으로 초기한 뒤 혼잡 회피 수행
   - 세 번의 중복 ACK 발생 : 빠른 재전송 후 회복 수행

2. 혼잡 회피
   RTT마다 혼잡 윈도의 IMSS씩 증가하는 알고리즘, 혼잡이 감지 되면 그 시점의 값을 절반으로 초기화한 뒤 다시 느린 시작 수행
3. 빠른 회복
	세 번의 중복 ACK 세그먼트 수신했을 때 느린 시작은 거너뛰고 혼잡 회피 수행하는 알고리즘 

### 명시적 혼잡 알림

혼잡 제어하기 위한 양 조절을 송신 호스트가 했는데 최근에는 네트워크 중간 장치의 도움을 받는 방법이 생김, 이를 명시적 혼잡 알림(ECN)이라고 한다
