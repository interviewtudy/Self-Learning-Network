# 전송 계층 개요: IP의 한계와 포트

## 신뢰할 수 없는 통신과 비연결형 통신

- IP 는 비신뢰성 프로토콜이자 비연결형 프로토콜임
- 비신뢰성 프로토콜
  - IP 프로토콜이 패킷이 수신지까지 제대로 전송되었다는 보장을 하지 않음
  - 패킷의 데이터가 손상되거나 중복된 패킷이 전송될 수 있고 순서대로 패킷이 보장할 것이라는 보장도 없음
  - 재전송도 하지 않음
  - 최선형 전달이라고도 부름(최선을 다하지만 전송 결과는 보장할 수 없음)
- 비연결형 통신
  - 송수신 호스트 간에 사전 연결 수립 작업을 거치지 않음
- 비신뢰성 & 비연결형 통신을 통해 성능상 이점을 봄

<br/><br/>

## IP 의 한계를 보완하는 전송 계층

- 전송 계층의 보완 방법
  1. 연결형 통신 가능: 전송 계층의 연결형 프로토콜인 TCP 는 두 호스트가 정보를 주고받기 전에 가상의 회선을 설정하듯 연결을 수립하고, 송수신이 끝나면 연결을 종료함
  2. 신뢰성 있는 통신 가능: TCP 는 패킷 순서를 보장하기 위해 재전송을 통한 오류 제어, 흐름 제어, 혼합 제어 등 다양한 기능을 제공함
- UDP 라는 비신뢰성, 비연결형 통신 또한 제공함

<br/><br/>

## 응용 계층과의 연결 다리, 포트

- 패킷의 최종 수신 대상은 애플리케이션 프로세스
- 포트: 패킷이 실행 중인 특정 애플리케이션까지 전달되기 위해 애플리케이션을 식별할 수 있는 정보
- 전송 계층에서는 포트 번호를 통해 특정 애플리케이션을 식별함

### 포트 분류

- TCP 와 UDP 는 포트 번호 필드인 송신지 포트 번호와 수신지 포트 번호를 포함함
- 포트 번호는 16비트로 표현

| 포트 종류                       | 포트 번호 범위 | 예제                                                                                    |
| ------------------------------- | -------------- | --------------------------------------------------------------------------------------- |
| 잘 알려진 포트                  | 0~1023         | SSH(22), HTTP(80), HTTPS(443)                                                           |
| 등록된 포트                     | 1024~49151     | MySQL 데이터베이스(3306), Redis(6379)                                                   |
| 동적 포트(사설 포트, 임시 포트) | 49152~65535    | 인터넷 할당 번호 관리 기간에 의해 할당된 애플리케이션 프로토콜 없음, 자유록베 사용 가능 |

- 서버로 동작하는 프로그램은 잘 알려진 포트와 등록된 포트로 동작하는 경우가 많음
- 클라이언트로 동작하느나 프로그램은 동적 포트 중에서 임의의 번호가 할당되는 경우가 많음(ex.웹 브라우저)
- IP 주소와 포트 번호에 대한 정보가 함께 주어지면 특정 호스트에서 실행 중인 특정 애플리케이션 프로세스를 식별할 수 있음 -> IP주소:포트번호 형식으로 IP 주소와 함께 표시하는 경우가 많음

<br/><br/>

## 포트 기반 NAT

### NAT 변환 테이블

- 변환의 대상이 되는 IP 주소 쌍이 명시되어 있음
- 일대일로 주소를 대응시키기도 하지만 오늘날엔 포트를 활용하여 하나의 공인 IP 주소에 여러 사설 IP 주소를 대응시킴

### NAPT(Network Address Port Translation)

- 포트를 활용해 하나의 공인 IP 주소를 여러 사설 IP 주소가 공유할 수 있도록 하는 NAT의 일종
- IP 주소가 같더라도 포트 번호가 다르면 다른 네트워크 내부의 호스트를 특정할 수 있다는 점을 이용

<br/><br/>

## 포트 포워딩

내트워크 내 특정 호스트에 IP 주소와 포트 번호를 미리 할당하고 해당 IP 주소:포트 번호로써 해당 해당 호스트에게 패킷을 전달하는 기능

- 네트워크 내부의 서버를 외부에서 접속할 수 있도록 접속 정보를 공개하기 위해 자주 사용
- 공인IP주소:1234 - 사설IP주소:내부포트 로 설정해둠
- 설정 해둔 값들이 NAT 테이블에 로드됨

<br/><br/>

## ICMP

네트워크 계층에서 비신뢰성 & 비연결성 특성을 보완하기 위한 프로토콜로 IP 패킷의 전송 과정에 대한 피드백 메시지를 얻기 위해 사용함

- ICMP 메시지 종류
  - 전송 과정에서 발생한 문제 상황에 대한 오류 보고
  - 네트워크에 대한 진단 정보(네트워크상의 정보 제공)
- ICMP 메시지는 타입과 코드로 정의
  - 타입: ICMP 메시지의 유형이 번호로 명시
  - 코드: 구체적인 메시지 내용이 번호로 명시
- 네트워크상의 간단한 문제 진단 및 테스트를 위해 사용되기도 함(ex. `traceroute`, `tracert`, `ping`)
- ICMP 는 IP 의 신뢰성을 보장하는 것이 아닌 비신뢰성을 보완하기 위해 도움을 주는 것에 그침

<br/><br/><br/><br/>

# TCP 와 UDP

## TCP 통신 단계와 세그먼트 구조

- TCP 통신 단계: 연결 수립 -> 데이터 송수신(재전송을 통한 오류 제어, 흐름 제어, 혼합 제어) -> 연결 종료
- MSS(Maximum Segment Size): TCP 로 전송할 수 있는 최대 페이로드 크기(TCP 헤더 크기 제외)

### TCP 세그먼트 헤더 구조

- 송신지 포트 & 수신지 포트: 송신지 & 수신지 애플리케이션 식별하는 포트 번호
- 순서 번호: 세그먼트의 올바른 순서를 보장하기 위해 세그먼트 데이터의 첫 바이트에 부여되는 번호
- 확인 응답 번호: 상대 호스트가 보낸 세그먼트에 대한 응답으로, 다음으로 수신하기를 기대하는 순서 번호
- 제어 비트: 플래그 비트라고도 부르며 현재 세그먼트에 대한 부가 정보를 나타냄
- 윈도우: 수신 윈도우(한 번에 수신하고자 하는 데이터의 양)의 크기 명시

### 제어 비트

- 8비트로 구성되며 각 자리의 비트는 각기 다른 의미를 가짐
- 세 개의 제어 비트
  - ACK: 세그먼트의 승인을 나타내기 위한 비트
  - SYN: 연결을 수립하기 위한 비트
  - FIN: 연결을 종료하기 위한 비트

### 순서 번호와 확인 응답 번호

TCP의 신뢰성을 보장하기 위해 사용되는 주요 필드

- 처음 통신을 위해 연결을 수립한 경우
  - SYN 플래그가 1로 설정된 세그먼트의 경우 순서 번호는 무작위 값(초기 순서 번호)이 됨
  - 초기 순서 번호를 가장 먼저 보내게 될 세그먼트에 할당
  - 데이터를 송신하는 동안 순서 번호는 송신한 바이트를 더해 가는 형태로 누적값을 가짐(초기 순서번호가 100, MSS를 500이라고 하면, 세그먼트A 데이터를 송신하는 동안 세그먼트B의 순서번호는 100+500=600 이됨)
- 순서 번호는 세그먼트상에서 32비트(4바이트)로 표현되고 표현 가능한 수를 넘어서면 0부터 다시 증가
- 확인 응답 번호는 순서번호에 대한 응답으로 일반적으로 수신한 순서 번호 + 1로 설정됨
- 확인 응답 번호를 보내기 위해서는 ACK 플래그를 1로 설정해야 함

<br/><br/>

## TCP 연결 수립과 종료

### 연결 수립: 쓰리 웨이 핸드셰이크

쓰리 웨이 핸드셰이크란 세 단계로 이루어진 TCP 의 연결 수립 과정을 의미함

| 송수신 방향 | 세그먼트           | 세그먼트 주요 정보                                                                                                    |
| ----------- | ------------------ | --------------------------------------------------------------------------------------------------------------------- |
| A->B        | SYN 세그먼트       | 호스트 A의 초기 순서 번호, 1로 설정된 SYN 비트                                                                        |
| B->A        | SYN + ACK 세그먼트 | 호스트 B의 초기 순서 번호, 호스트 A가 전송한 세그먼트에 대한 확인 응답 번호, 1로 설정된 SYN 비트, 1로 설정된 ACK 비트 |
| A->B        | ACK 세그먼트       | 호스트 A의 다음 순서 번호, 호스트 B가 전송한 세그먼트에 대한 확인 응답 번호, 1로 설정된 ACK 비트                      |

- 액티브 오픈: 처음 연결을 시작하는 호스트의 연결 수립 과정. 서버 - 클라이언트 관계에서 클라이언트에 의해 주로 수행됨
- 패시브 오픈: 연결 요청을 받고 나서 요청에 따라 연결을 수립해주는 호스트의 연결 수립 과정. 서버에 의해 주로 수행됨

### 연결 종료

송수신 호스트가 각자 한 번씩 FIN 과 ACK 를 주고 받으며 이루어짐

| 송수신 방향 | 세그먼트     | 세그먼트에 포함된 주요 정보                                           |
| ----------- | ------------ | --------------------------------------------------------------------- |
| A->B        | FIN 세그먼트 | 1로 설정된 FIN 비트                                                   |
| B->A        | ACK 세그먼트 | 호스트 A가 전송한 세그먼트에 대한 확인 응답 번호, 1로 설정된 ACK 비트 |
| B->A        | FIN 세그먼트 | 1로 설정된 FIN 비트                                                   |
| A->B        | ACK 세그먼트 | 호스트 B가 전송한 세그먼트에 대한확인 응답 번호, 1로 설정된 ACK 비트  |

- 액티브 클로즈: 먼저 연결을 종료하려는 호스트에 의해 수행
- 패시브 클로즈: 연결 종료 요청을 받아들이려는 호스트에 의해 수행

<br/><br/>

## TCP 상태

TCP 는 연결형 통신과 신뢰할 수 있는 통신을 유지하기 위해 다양한 상태를 유지함(스테이트풀 프로토콜)

- 상태: 어떤 통신 과정에 있는지를 나타내는 정보
- 종류
  - 연결이 수립되지 않은 상태: CLOSED, LISTEN
  - 연결 수립 과정에서 주로 볼 수 있는 상태: SYN-SENT, SYN-RECEIVED, ESTABLISHED
  - 연결 종료 과정에서 주로 볼 수 있는 상태: FIN_WAIT-1, CLOSE-WAIT, FIN-WAIT-2, LAST-ACK, TIME-WAIT, CLOSING
- TCP 의 다양한 상태는 간단한 명령어로 확인 가능: `netstat`

### 연결이 수립되지 않은 상태

- CLOSED: 아무런 연결이 없는 상태
- LISTEN: 일종의 연결 대기 상태. 패시브 오픈 호스트가 유지하는 상태로, SYN 세그먼트를 기다리는 상태.

### 연결 수립 상태

- SYN-SENT: 액티브 오픈 호스트가 SYN + ACK 세그먼트를 기다리는 상태
- SYN-RECEIVED: 패시브 오픈 호스트가 ACK 세그먼트를 기다리는 상태
- ESTABLISHED: 두 호스트가 마지막 ACK 세그먼트를 주고받았을 때 접어드는 상태로, 연결이 확립되어 데이터 송수신이 가능한 상태

### 연결 종료 상태

- FIN-WAIT-1: 액티브 클로즈 호스트가 FIN 세그먼트를 보내 연결 종료 요청을 보낸 상태
- CLOSE-WAIT: 패시브 클로즈 호스트가 ACK 응답을 보낸 후 대기하는 상태
- FIN-WAIT-2: 액티브 클로즈 호스트가 ACK 세그먼트를 받고 상대의 FIN 세그먼트를 기다리는 상태
- LAST-ACK: 패시브 클로즈 호스트가 CLOSE-WAIT 상태에서 FIN 세그먼트를 전송한 후 ACK을 기다리는 상태
- TIME-WAIT: 액티브 클로즈 호스트가 FIN 세그먼트를 수신 한뒤 ACK 세그먼트를 전송한 후 접어드는 상태. 패시브 클로즈 호스트는 ACK 을 수신하면 CLOSED 로 전이하지만 TIME-WAIT 상태에 접어든 액티브 클로즈 호스트는 잠시 대기한 후 CLOSED 상태로 전이함(마지막으로 보낸 ACK 세그먼트가 올바르게 전송되지 않았을 수 있기 때문에 대기해야 함)
- CLOSING: 동시에 연결을 종료하려 할 때 전이되는 상태. 상대의 FIN 세그먼트에 대해 ACK 세그먼트를 보냈지만 아직 자신의 FIN 세그먼트의 ACK 세그먼트를 받지 못했을 때 접어드는 상태로, ACK 세그먼트를 수신한다면 각자 TIME-WAIT 상태로 접어든 후 종료하게 됨

<br/><br/>

## UDP 데이터그램 구조

- TCP처럼 상태를 유지하지 않고, 활용하지도 않음(스테이트리스 프로토콜의 일종)
- 송신지 포트, 수신지 포트, 길이, 체크섬 필드 네 개로 구성
  - 송신지 포트 & 수신지 포트: 송수신지의 포트 번호
  - 길이: 헤더를 포함한 UDP 다이어그램의 바이트
  - 체크섬: 데이터그램 전송 과정에서 오류가 발생했는지 검사하기 위한 필드. 데이터그램 정보의 훼손 여부를 나타내며, 수신지에 잘 도착했는지와는 무관함
- 실시간 스트리밍 서비스, 인터넷 전화 등 실시간성이 강조되는 상황에서 TCP 보다 많이 쓰이며, 적은 오버헤드로 패킷을 빠르게 처리할 수 있음
- 패킷이 손실되거나 순서가 바뀔 수 있음

<br/><br/><br/><br/>

# TCP의 오류,흐름,혼합 제어

## 오류 제어: 재전송 기법

### 오류 검출과 재전송

신뢰성을 보장하기 위해서는 오류를 검출할 수 있어야 하고, 오류가 검출될 경우 재전송할 수 있어야 함

- TCP 가 세그먼트에 문제가 있음을 감지하는 상황
  - 중복된 ACK 세그먼트를 수신했을 때
  - 타임아웃이 발생했을 때: TCP 세그먼트를 송신하는 호스트는 모두 재전송 타이머라는 값을 유지함. 호스트는 세그먼트를 전송할 때마다 재전송 타이머를 시작하게 되고, 이 타이머의 카운트 다운이 끝난 상황을 타임아웃이라고 함. 타임아웃이 끝날 때까지 ACK 세그먼트를 받지 못하면 세그먼트가 상대 호스트에 정상적으로 도착하지 않았다고 간주함
- RTT(Round Trip Time): 메시지를 전송한 뒤 그에 대한 답변을 받는 데 까지 걸리는 시간

### 재전송 기법: ARQ(Automatic Repeat Request, 자동 재전송 요구)

ACK 와 타임아웃 발생을 토대로 문제를 진단하고 문제가 생긴 메시지를 재전송함으로써 신뢰성을 확보하는 방식

- Stop-and-Wait ARQ:
  - 제대로 전달했음을 확인하기 전까지는 새로운 메시지를 보내지 않는 방식
  - 단순하지만 높은 신뢰성을 보장함
  - 한 번에 여러개의 응답을 전송받을 수 있음에도 한 번에 하나의 확인 응답만 보내야 하므로 네트워크 이용 효율이 낮아져 성능 저하를 일으킬 수 있음 -> 오늘날엔 잘 쓰이지 않음
- Go-Back-N ARQ
  - 파이프라이닝을 통해 연속해서 여러 세그먼트를 전송하고, 도중에 잘못 전송된 세그먼트가 발생하면 해당 세그먼트부터 재전송함
  - 수신 호스트는 그 이후 세그먼트를 올바르게 수신했다 해도 이를 폐기
  - 순서 번호 n 번에대한 ACK 세그먼트는 n번에만 해당하는 확인 응답이 아니라 n번까지의 확인 응답이라고 볼 수 있어 **누적 확인 응답** 이라고도 함
- Selective Repeat ARQ
  - 수신 호스트 측에서 제대로 전송받은 각각의 패킷들에 대해 ACK 를 보내고 올바르게 수신하지 못한 ACK 세그먼트가 있는지 검사해 응답받지 못한 세그먼트가 있다면 재전송하는 방법(즉, 선택적으로 재전송는 방식)
  - ACK 세그먼트가 개발 확인 응답임
  - 오늘날의 대부분의 호스트는 Selective Repeat ARQ 를 지원하고 이를 사용하지 않을 경우 Go-Back-N ARQ 방식으로 동작함
  - TCP 세그먼트 헤더의 옵션 필드에 SACK 허용 필드를 통해 지원 여부를 알 수 있음

### 빠른 재전송

재전송 타이머가 만료되기 전이라도 세 번의 동일한 ACK 세그먼트가 수신되었다면 해당 세그먼트를 곧바로 전송하는 기능

- 유실된 세그먼트는 원래 재전송 타이머가 만료되었을 때 재전송 하지만 빠른 재전송은 타이머가 끝나기 전에 재전송을 수행함
- 시간 낭비를 줄여 성능을 높이는 기능

<br/><br/>

## 흐름 제어: 슬라이딩 윈도우

- 호스트가 한 번에 받아서 처리할 수 있는 세그먼트 양에는 한계가 있음 -> 흐름 제어가 필요함
- 흐름 제어를 통해 수신 호스트의 처리 속도를 고려하여 송신 호스트가 송수신 속도를 균일하게 유지함
- 수신 버퍼: 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전, 임시로 저장되는 공간. 수신 버퍼 크기보다 많은 데이터를 전송하면 일부 세그먼트가 처리되지 못할 수 있음
- 버퍼 오버플로우: 버퍼가 넘치는 문제 상황
- 송신 버퍼: 송신할 세그먼트가 저장되는 공간
- 윈도우: 송신 호스트가 파이프라이닝 할 수 있는 최대량. 확인 응답을 받지 않고 한 번에 전송 가능한 크기
- 슬라이딩 윈도우
  - 윈도우 크기만큼의 세그먼트를 전송하고 전송한 세그먼트에 대한 ACK 이 올 때마다 윈도우를 한 칸씩 이동시킴
  - 송신 호스트와 수신 호스트 모두 윈도우를 고려하고 송신 윈도우는 수신 호스트가 알려주는 수신 윈도우(RWND, Receiver WiNDow)를 토대로 알 수 있는 정보임(수신 호스트는 TCP 헤더의 윈도우 필드를 통해 송신 호스트에게 받아들이고자 하는 데이터 양을 알림)

<br/><br/>

## 혼잡 제어

- 혼잡: 많은 트래픽으로 인해 패킷의 처리 속도가 늦어지거나 유실될 우려가 있는 네트워크 상황
- 혼잡 붕괴: 혼잡으로 인해 전송률이 크게 떨어지는 현상
- 혼합 제어는 혼잡을 제어하기 위한 기능으로, 흐름 제어의 주체가 수신 호스트라면 혼잡 제어의 주체는 송신 호스트임
- 송신 호스트는 네트워크의 혼잡도롤 파악하고 유동적으로 전송량을 조절하여 전송함
- 혼잡 윈도우(CWND, Congestion WiNDow): 혼잡 없이 전송할 수 있을 법한 데이터양으로 수신 윈도우 크기와 달리 직접 계산해서 알아내야 함

### 혼잡 제어 알고리즘

- AIMD(Additive Increase/Multiplicative Decrease)
  - 혼잡이 감지되지 않는다면 혼잡 윈도우를 RTT 마다 1씩 선형적으로 증가 시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 동작을 반복하는 알고리즘(합으로 증가, 곱으로 감소)
  - 혼잡 제어에 대한 기본적인 아이디어지만 이것만으로 혼잡 제어가 이루어지진 않음
- 느린 시작 알고리즘
  - 혼잡 윈도우를 1로 시작해 문제 없이 수신된 ACK 세그먼트에 따라 1씩 증가 시키는 방식
  - 혼잡윈도우:1 -> 송신1 -> 확인1 -> 혼잡윈도우:1+1=2 -> 송신2 -> 확인2 -> 혼잡윈도우: 2+2=4...
  - RTT 마다 2배씩 지수적으로 증가하게 되므로 초기 전송 속도를 확보할 수 있음
  - 지수적으로 증가하는 한계치, 즉 느린 시작 임계치(SSTHRESH, Slow Start THRESHold)를 두어 혼잡 감지 시 다음과 같이 처리
    - 타임아웃 발생: 혼잡 윈도우 값을 1로 초기화하고 느린 시작 임계치를 혼잡 감지 시 혼잡 윈도우 값의 절반으로 초기화한 후 느린 시작 재개
    - 혼잡 윈도우 >= 느린 시작 임계치: 느린 시작 종료. 혼잡 윈도우를 절반으로 초기화한 뒤 혼잡 회피 수행
    - 세 번의 중복 ACK 발생: (빠른 재전송 후) 빠른 회복 수행
- 혼잡 회피 알고리즘
  - RTT 마다 혼잡 윈도우를 1MSS씩 증가시키는 알고리즘
  - 혼잡 윈도우 크기를 선형적으로 증가시키는 방식으로, 느린 시작 임계치를 넘어서면 혼잡이 발생할 우려가 있으니 조심해서 혼잡 윈도우를 증가시키는 방식
  - 혼잡 회피 도중 세 번의 중복 ACK 가 발생됐을 때는 혼잡 윈도우 값과 느린 시작 임계치를 대략 절반으로 떨어뜨린 후 빠른 회복 알고리즘을 수행함. 이 때 타임아웃이 발생한 세그먼트나 세 번의 중복 ACK 세그먼트가 발생한 세그먼트는 재전송
- 빠른 회복 알고리즘
  - 세 번의 중복 ACK 세그먼트를 수신했을 때 느린 시작은 건너뛰고 혼잡 회피를 수행하는 알고리즘으로 빠르게 전송률을 회복하기 위한 알고리즘
  - 빠른 재전송과 더불어 수행됨
  - 빠른 회복 중이라도 타임아웃이 발생하면 혼잡 윈도우 크기는 1로, 느린 시작 임계치는 혼잡 감지 시점의 절반으로 떨어뜨린 후 다시 느린 시작을 수행함ㄷ

<br/><br/>

## ECN: 명시적 혼잡 알림

혼잡을 피하기 위해 네트워크 중간 장치(주로 라우터)의 도움을 받는 방법

- 지원하는 호스트와 지원하지 않는 호스트가 있음
- TCP/IP 프로토콜로 정보를 주고 받을 때 IP 헤더와 TCP 헤더에 ECN 관련 필드가 추가됨
  - IP(IPv4) 헤더: 서비스 필드내 오른쪽 두 비트
  - TCP 헤더: 제어 비트의 CWR 비트, ECE 비트
- ECN 은 선택적 기능으로 양쪽 호스트가 모두 ECN 기능을 지원해야 사용할 수 있음
- ECN 이용 시 수신 호스트의 ACK 세그먼트를 통해 더 빠르게 혼잡을 감지할 수 있고 일반적으로 혼잡 제어 방식에 비해 더 빠름(타임아웃, 중복된 ACK 세그먼트의 수신 같은 문제가 발생해야만 혼잡 제어가 수행되므로)
